<!DOCTYPE html>
<html lang="en">
<head>
    <title>3D Iteration 3</title>
    <meta charset="utf-8">
    <script src="3DStuff3.js"></script>

    <style>
    canvas {
        /*border: 2px solid black;*/
        position: absolute;
    }
    #canvases {
        width: 800px;
        height: 500px;
        border: 2px solid black;
        position: relative;
    }
    #background {
        z-index: 1;
    }
    #main {
        z-index: 2;
    }
    </style>
    <link href="../../bensite.css" rel="stylesheet">
</head>

<body>

    <nav>
        <ul>
            <li><a href="../Main_Page/projects_page.html">Back to Project List</a></li>
            <li><a href="3D_main.html">Back to 3D Main Page</a></li>
            <li><a href="3D_1.html">Iteration 1</a></li>
            <li><a href="3D_2.html">Iteration 2</a></li>
            <li>Iteration 3</li>
        </ul>
    </nav>

    <div class="main">

    <div>
        <h3>Controls</h3>
        <p>The left and right arrow keys turn the camera left and right.</p>
        <p>Use WASD to move.</p>
        <p>For those unfamiliar, W moves forward, S moves backward, A moves
            left, and D moves right. It's like the arrow keys for your left
            hand.
        </p>
        <h3>Tip</h3>
        <p>Look to your left first. The space is very empty, and the only
            landmark can be hard to find if you go wandering off.
        </p>
    </div>

    <div>
    <button onclick="start()">Start</button>
    </div>

    <div id="canvases">
        <canvas id="background" width="800" height="500">Canvas?</canvas>
        <canvas id="main" width="800" height="500">Canvas?</canvas>
    </div>

    <div>
        <h3>Explanation</h3>
        <p>As mentioned at the end of the previous iteration's explanation,
            I had no need for infinite walls once I made posts. I could just
            use the points generated by the posts to create polygons. Such
            polygons would appear as walls when opaque (as walls often are).
        </p>
        <p>While this approach was nice and simple, with how little new code
            was required, it has a rather significant drawback. It took me a
            long time to fail to fix it. It's roughly the same issue that the
            infinite wall had in the previous iteration.
        </p>
        <p>When a post is behind the view, it will still render the connected
            wall(s). You might think an appropriate solution is to simply
            detect whether the post is visible and not render any walls it
            connects to. This does not work, because the wall should still be
            partially visible.
        </p>
        <p>You can see this in action if you go inside the square. Any walls
            partially in view start doing some weird, disorienting things.
        </p>
        <p>That said, it looks perfectly fine when observing the square from
            the outside. The perspective works as it's supposed to, and it's
            impressive enough that I managed to make some real-time,
            first-person 3D thing using only basic trig and other simple
            functions.
        </p>
        <h3>Next Steps</h3>
        <p>One idea I have is to create a line perpendicular to the view and
            find any intersections it has with walls. I would then use these
            intersections to draw the walls instead of any posts that are
            behind the view.
        </p>
        <p>Beyond fixing bugs, other things I might add include the ability
            to look up. In theory, this would be as simple as raising and
            lowering the y position of the vanishing line. I wouldn't be
            surprised if I'm overlooking something that would cause me much
            trouble further on.
        </p>
        <p>Other than that, all I would need to add is some collision with
            the walls, some simple opponent AI, and perhaps a way of
            projecting images onto the walls, and I would have myself
            something close to those first-person games from the early to
            to mid '90s (e.g.
            <a href="https://en.wikipedia.org/wiki/Wolfenstein_3D">Wolfenstein 3D</a>,
            <!--a href="https://en.wikipedia.org/wiki/Doom_(1993_video_game)">Doom</a-->
            <a href="https://en.wikipedia.org/wiki/The_Elder_Scrolls">The Elder Scrolls 1 & 2</a>
            ).
        </p>
        <h3>Okay, but why not use [3D system]?</h3>
        <p>I actually did look into WebGL and OpenGL at one point. However,
            I'm not particularly interested in learning a shader language.
            If I'm going to make more complex 3D scenes, I might as well use
            a library or engine that does most of that work for me (e.g.
            <a href="https://threejs.org">three.js</a>,
            <a href="https://godotengine.org">Godot</a>
            ). While this doesn't allow me the luxury of code-defined
            environments, I bet I could still do some fun stuff.
        </p>
        <p>No matter what I do, though, any new progress on this project
            will require me to learn something. If I continue on my 2D
            path, I'll need to freshen up on transformation matrices in
            order to project an image onto walls. If I go the three.js
            route, I'll need to learn it from the beginning. Who knows!
            Maybe I'll learn a shader language anyway and make some 3D
            stuff from scratch.
        </p>
        <p>If I had to say which way I'm leaning now, I'd say I want to
            do three.js. It looks like a happy middle between super
            complicated math and learning a shader language from scratch.
            The quantity of new things to learn is large, but it's
            easier stuff than the alternatives.
        </p>
    </div>

    </div>
    
</body>
</html>