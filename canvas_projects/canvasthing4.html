<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Freecell</title>

<style>
#canvas {
	border: 2px solid darkgreen;
	background-color: green;
	border-radius: 5px;
}
</style>

<script>
// Reorganize code:
// Don't make Card a class - use a JS object constructor instead
//	You don't need to deal with inheritence for this
// Use global variables for gameBoard[] and the like
//	Remove memory leak issue where you can have multiple game instances
//	Take functions out of gameLoop()
// Take out unnecessary comments
//	Mostly old code left in for sentimental reasons
// Try abstracting cases
//	I don't want to rewrite the same cases three times
// Make animation code not a pile of junk
class Card {
	constructor(face, suit) {
		this.face = face;
		this.suit = suit;
		//this.width = 60;
	}
	color() {
		if (this.suit == "h" || this.suit == "d")
			return "red";
		else
			return "black";
	}
	print() {
		var suitprint = "";
		if (this.suit == "s")
			suitprint = "spades";
		else if (this.suit == "c")
			suitprint = "clubs";
		else if (this.suit == "d")
			suitprint = "diamonds";
		else if (this.suit == "h")
			suitprint = "hearts";
		else
			suitprint = "no suit";
		
		let faceprint
		if (this.face == 0)
			faceprint = "A";
		else if (this.face == 10)
			faceprint = "J";
		else if (this.face == 11)
			faceprint = "Q";
		else if (this.face == 12)
			faceprint = "K";
		else
			faceprint = this.face + 1;
		
		return faceprint + " of " + suitprint;
	}
}

class BoardDisp {
	constructor() {
		this.lmargin = 35;
		this.width = 60;
		this.spacing = 30;
		this.offset = Math.round(this.spacing / 2);
		this.spacing2 = 20;
		this.offset2 = Math.round(this.spacing2 / 2);
		// Add leftmost from gameLoop. It's super annoying to recalculate all the time.
		
		this.vmargin = 40;
		this.height = Math.round(this.width * 8 / 5);
		this.vmiddle = 30;
		this.areatop = this.vmargin + this.height + this.vmiddle;
		this.vspacing = 25;
	}
	
	findRow(xInput) {
		return Math.floor((xInput - this.lmargin) / (this.width + this.spacing));
	}
	findDrawX(row) {
		return (row * (this.width + this.spacing)) + this.lmargin + this.offset;
	}
	findCol(rowlength, yInput) {
		if (rowlength < 10) {
			let col = Math.floor((yInput - this.areatop) / this.vspacing);
			if (col > rowlength - 1 && yInput < this.areatop + (rowlength*this.vspacing) + this.height) {
				return rowlength - 1;
			}
			else if (col < rowlength) {
				return col;
			}
		}
		else {
			let col = Math.floor((yInput - this.areatop) / (this.vspacing * (10 / rowlength)));
			if (col > rowlength - 1 && yInput < this.areatop + (this.vspacing * 10) + this.height) {
				return rowlength - 1;
			}
			else if (col < rowlength) {
				return col;
			}
		}
	}
	findDrawY(rowlength, y) {
		if (rowlength < 10)
			return this.areatop + this.vspacing * y;
		else
			return this.areatop + y * (this.vspacing * (10 / rowlength));
	}
}

/*
var BoardDisp = {
	lmargin: 50,
	width: 60,
	spacing: 30,
	offset: Math.round(this.spacing / 2),
	
	vmargin: 40,
	height: Math.round(this.width * 8 / 5),
	vmiddle: 30,
	areatop: this.vmargin + this.height + this.vmiddle,
	vspacing: 25,
	
	findRow: function(xInput) {
		return Math.floor((xInput - this.margin) / (this.width + this.spacing));
	},
	findDrawX: function(row) {
		return (row * (this.width + this.spacing)) + this.margin + this.offset;
	},
	findCol: function(rowlength,yInput) {
		if (rowlength < 10)
			return Math.floor((yInput - this.areatop) / this.vspacing);
		else
			return Math.floor((yInput - this.areatop) / (this.vspacing * (10 / rowlength)));
	},
	findDrawY: function(rowlength, y) {
		if (rowlength < 10)
			return this.areatop + this.vspacing * y;
		else
			return this.areatop + y * (this.vspacing * (10 / rowlength));
	}
};
*/


function fillRectCurved(x, y, width, height, border_radius) {
	var rad = border_radius;
	var canvas = document.getElementById("canvas");
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		/*
		draw2d.beginPath();
		draw2d.arc(50,50, 10, Math.PI,3*Math.PI/2, false);
		draw2d.fill();
		draw2d.beginPath();
		draw2d.arc(60,50,10, 3*Math.PI/2,2*Math.PI, false);
		draw2d.fill();
		draw2d.beginPath();
		draw2d.arc(60,60,10, 0,Math.PI/2, false);
		draw2d.fill();
		draw2d.beginPath();
		draw2d.arc(50,60, 10, Math.PI/2,Math.PI, false);
		draw2d.fill();
		*/
		draw2d.beginPath();
		draw2d.moveTo(x+rad,y);
		draw2d.arc(x+rad,y+rad, rad, Math.PI,3*Math.PI/2, false); //TL corner
		draw2d.lineTo(x+width-rad,y);
		draw2d.lineTo(x+width,y+rad);
		draw2d.arc(x+width-rad,y+rad, rad, 3*Math.PI/2,2*Math.PI, false); // TR corner
		draw2d.lineTo(x+width,y+height-rad);
		draw2d.lineTo(x+width-rad,y+height);
		draw2d.arc(x+width-rad,y+height-rad, rad, 0,Math.PI/2, false); //BR corner
		draw2d.lineTo(x+rad,y+height);
		draw2d.lineTo(x,y+height-rad);
		draw2d.arc(x+rad,y+height-rad, rad, Math.PI/2,Math.PI, false); // BL corner
		draw2d.lineTo(x,y+rad);
		
		draw2d.fill();
	}
	//console.log("drew curved rectangle");
}

function drawSpade(x,y) {
	var canvas = document.getElementById("canvas");
	
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		
		// Two circles
		draw2d.beginPath();
		draw2d.arc(x-5,y, 8, 0,2*Math.PI, true);
		draw2d.moveTo(x+5,y)
		draw2d.arc(x+5,y, 8, 0,2*Math.PI, true);
		
		draw2d.fill();
		
		// Top part
		draw2d.beginPath();
		draw2d.moveTo(x-13,y)
		draw2d.bezierCurveTo(x-13,y-6, x-5,y-18, x,y-20);
		draw2d.bezierCurveTo(x+5,y-18, x+13,y-6, x+13,y);
		
		draw2d.fill();
		
		// Bottom part
		draw2d.beginPath();
		draw2d.moveTo(x-8,y+15);
		draw2d.bezierCurveTo(x,y+15, x-2,y+12, x,y);
		draw2d.bezierCurveTo(x+2,y+12, x,y+15, x+8,y+15);
		
		draw2d.fill();
	}
}

function drawClub(x,y) {
	var canvas = document.getElementById("canvas");
	
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		
		// Circles
		draw2d.beginPath();
		draw2d.arc(x-8,y, 8, 0,2*Math.PI, true);
		draw2d.moveTo(x+8,y);
		draw2d.arc(x+8,y, 8, 0,2*Math.PI, true);
		draw2d.moveTo(x,y-13);
		draw2d.arc(x,y-10, 8, 0,2*Math.PI, true);
		
		draw2d.fill();
		
		draw2d.arc(x,y, 2, 0,2*Math.PI, true);
		draw2d.fill()
		
		// Bottom part
		draw2d.beginPath();
		draw2d.moveTo(x-8,y+15);
		draw2d.bezierCurveTo(x,y+15, x-2,y+12, x,y);
		draw2d.bezierCurveTo(x+2,y+12, x,y+15, x+8,y+15);
		
		draw2d.fill();
	}
}

function drawDiamond(x,y) {
	var canvas = document.getElementById("canvas");
	
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		
		draw2d.fillStyle = "red";
		
		draw2d.beginPath();
		draw2d.lineTo(x-13,y);
		draw2d.lineTo(x,y-15);
		draw2d.lineTo(x+13,y);
		draw2d.lineTo(x,y+15);
		
		draw2d.fill();
	}
}

function drawHeart(x,y) {
	var canvas = document.getElementById("canvas");
	
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		
		draw2d.fillStyle = "red";
		
		// Two circles
		draw2d.beginPath();
		draw2d.arc(x-6,y-6, 8, 0,2*Math.PI, true);
		draw2d.moveTo(x+5,y)
		draw2d.arc(x+6,y-6, 8, 0,2*Math.PI, true);
		
		draw2d.fill();
		
		// Top part
		draw2d.beginPath();
		draw2d.moveTo(x-14,y-6);
		draw2d.bezierCurveTo(x-15,y+5, x-2,y+8, x,y+15);
		draw2d.bezierCurveTo(x+2,y+8, x+15,y+5, x+14,y-6);
		
		draw2d.fill();
	}
}

function drawCard(x, y, card) {
	const curve = 5;
	
	var canvas = document.getElementById("canvas");
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		//draw2d.fillRect(40,40, 100,100);
		//console.log("drawing card at " + x + "," + y);
		//draw2d.fillRect(x,y,100,100);
		var brdDraw = new BoardDisp();
		
		var cardWidth = brdDraw.width;
		var cardHeight = brdDraw.height;
		
		draw2d.fillStyle = "lightgray";
		fillRectCurved(x-2,y-2, cardWidth+4,cardHeight+4, curve);
		//draw2d.fillRect(x-2,y-2, cardWidth+4,cardHeight+4);
		draw2d.fillStyle = "white";
		fillRectCurved(x,y, cardWidth,cardHeight, curve);
		//draw2d.fillRect(x,y, cardWidth,cardHeight);
		
		if (card.color() == "red")
			draw2d.fillStyle = "red";
		else
			draw2d.fillStyle = "black";
		
		let text2draw;
		if (card.face == 0)
			text2draw = "A";
		else if (card.face == 10)
			text2draw = "J";
		else if (card.face == 11)
			text2draw = "Q";
		else if (card.face == 12)
			text2draw = "K";
		else
			text2draw = card.face + 1;
		draw2d.font = "15px sans-serif";
		draw2d.fillText(text2draw, x+(cardWidth/10),y+10+(cardWidth/10));
		//draw2d.fillText(card.suit, x+(cardWidth/10),y+10+Math.round((cardHeight/6)));
		
		if (card.suit == "s")
			drawSpade(x+(cardWidth/2),y+(cardHeight/2));
		else if (card.suit == "c")
			drawClub(x+(cardWidth/2),y+(cardHeight/2));
		else if (card.suit == "h")
			drawHeart(x+(cardWidth/2),y+(cardHeight/2));
		else if (card.suit == "d")
			drawDiamond(x+(cardWidth/2),y+(cardHeight/2));
		else
			draw2d.fillText(card.suit, x+(cardWidth/10),y+10+Math.round(cardHeight/6));
		
	}
}

function drawBoard(board, winDecks, freeSpaces, exception) {
	var canvas = document.getElementById("canvas")
	
	if (canvas.getContext) {
		var draw2d = canvas.getContext("2d");
		//draw2d.fillRect(40,40, 100,100);
		
		draw2d.fillStyle = "green";
		draw2d.fillRect(0,0, 800,500);
		
		var fmat = new BoardDisp();
		
		// Undo button
		draw2d.fillStyle = "darkgreen";
		draw2d.beginPath();
		draw2d.arc(400,fmat.vmargin+(fmat.height/2), 20, 0,2*Math.PI, true);
		draw2d.fill();
		
		// Main Area
		for (let i = 0; i < board.length; i++) {
			if (exception == undefined) {
				if (board[i].length == 0) {
					draw2d.fillStyle = "darkgreen";
					draw2d.fillRect(fmat.findDrawX(i), fmat.areatop, fmat.width, fmat.height);
				}
				else {
					for (let j = 0; j < board[i].length; j++) {
						drawCard(fmat.findDrawX(i), fmat.findDrawY(board[i].length,j), board[i][j]);
						//console.log("card " + board[i][j].print() + " drawn");
					}
				}
			}
			else {
				if (i == exception[0]) {
					for (let j = 0; j < exception[1]; j++) {
						drawCard(fmat.findDrawX(i), fmat.findDrawY(board[i].length,j), board[i][j]);
					}
				}
				else {
					// Repeated code!? Who the hell programmed this?
					if (board[i].length == 0) {
						draw2d.fillStyle = "darkgreen";
						draw2d.fillRect(fmat.findDrawX(i), fmat.areatop, fmat.width, fmat.height);
					}
					else {
						for (let j = 0; j < board[i].length; j++) {
							drawCard(fmat.findDrawX(i), fmat.findDrawY(board[i].length,j), board[i][j]);
						}
					}
				}
			}
		}
		
		// Free Cells
		for (let i = 0; i < 4; i++) {
			if (exception == undefined) {
				if (freeSpaces[i] == undefined) {
					draw2d.fillStyle = "darkgreen";
					draw2d.fillRect(fmat.lmargin + fmat.offset + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, fmat.width,fmat.height);
				}
				else {
					drawCard(fmat.lmargin + fmat.offset2 + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, freeSpaces[i]);
				}
			}
			else {
				if (freeSpaces[i] == undefined || (exception[0] == -1 && exception[1] == i)) {
					draw2d.fillStyle = "darkgreen";
					draw2d.fillRect(fmat.lmargin + fmat.offset + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, fmat.width,fmat.height);
				}
				else {
					drawCard(fmat.lmargin + fmat.offset2 + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, freeSpaces[i]);
				}
			}
		}
		
		// Win Decks
		let leftmost = fmat.findDrawX(board.length - 1) - (3 * (fmat.spacing2 + fmat.width));
		for (let i = 0; i < 4; i++) {
			if (i > winDecks.length - 1) {
				draw2d.fillStyle = "darkgreen";
				draw2d.fillRect(leftmost + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, fmat.width,fmat.height);
			}
			else {
				//drawCard(fmat.findDrawX(board.length-1) - ((fmat.spacing2+fmat.width) * i), fmat.vmargin, fmat.width,fmat.height);
				drawCard(leftmost + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, winDecks[i]);
				if (exception == undefined) {
					drawCard(leftmost + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, winDecks[i]);
				}
				else if (exception[0] == -2 && exception[1] == i) {
					let undercard = winDecks[i];
					if (undercard.face > 0) {
						undercard.face--;
						drawCard(leftmost + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, undercard);
					}
					else {
						draw2d.fillStyle = "darkgreen";
						draw2d.fillRect(leftmost + ((fmat.spacing2+fmat.width) * i), fmat.vmargin, fmat.width, fmat.height);
					}
				}
			}
		}
	}
}

function gameLoop(brd) {
	
	var gameBoard = brd;
	
	var winDecks = [];
	//var nullcard = new Card(-1,"no");
	var freeSpaces = [undefined, undefined, undefined, undefined];
	
	var win = false;
	
	var moves = [];
	var undo = false;
	
	var animate = false;
	var animatedcard = [];
	var animatepos = [NaN,NaN];
	var cardoffset = [NaN,NaN];
	var travel = [0,0,0];
	
	var move = false;
	var movepos = [NaN,NaN];
	var movedir = [0,0];
	var movespeed = 0;
	var moveframe = 0;
	var movedist = 0;
	
	var move1 = [];
	var move2 = [];
	
	let fmat = new BoardDisp();
	let leftmost = fmat.findDrawX(gameBoard.length - 1) - (3 * (fmat.spacing2 + fmat.width));
	var wincard = {
		index: [0,0],
		x: leftmost,
		y: fmat.vmargin,
		dx: 0,
		dy: 0,
		grav: 1,
		damping: 0.8
	}
	delete(fmat);
	delete(leftmost);
	
	
	function distance(x1,y1,x2,y2) { return Math.sqrt( (x2-x1) ** 2 + (y2-y1) ** 2 ); }
	
	function animateDrag() {
		
		if (animate) {
			drawBoard(gameBoard, winDecks, freeSpaces, animatedcard);
			
			if (animatedcard[0] > -1) {
				for (let i = animatedcard[1]; i < gameBoard[animatedcard[0]].length; i++) {
					drawCard(animatepos[0],animatepos[1] + (25 * (i - animatedcard[1])), gameBoard[animatedcard[0]][i]);
				}
			}
			else if (animatedcard[0] == -1)
				drawCard(animatepos[0],animatepos[1], freeSpaces[animatedcard[1]]);
			else if (animatedcard[0] == -2)
				drawCard(animatepos[0],animatepos[1], winDecks[animatedcard[1]]);
			
			window.requestAnimationFrame(animateDrag);
		}
		//else
		//	drawBoard(gameBoard, winDecks, freeSpaces, undefined);
		
	}
	
	function animateMove() {
		
		if (move) {
			drawBoard(gameBoard, winDecks, freeSpaces, animatedcard);
			
			//console.log(animatedcard);
			if (animatedcard[0] > -1) {
				for (let i = animatedcard[1]; i < gameBoard[animatedcard[0]].length; i++) {
					drawCard(movepos[0],movepos[1], gameBoard[animatedcard[0]][i]);
				}
			}
			else if (animatedcard[0] == -1)
				drawCard(movepos[0],movepos[1], freeSpaces[animatedcard[1]]);
			else if (animatedcard[0] == -1)
				drawCard(animatepos[0],animatepos[1], winDecks[animatedcard[1]]);
			
			// Need to finish this
			// change movepos by movedir * movespeed
			// change movespeed
			movepos[0] += movedir[0] * movespeed;
			movepos[1] += movedir[1] * movespeed;
			//movespeed = ((Math.PI/2) + Math.atan((moveframe - 15) * 1));
			if (moveframe < 15)
				movespeed += movedist / 230;
			else
				movespeed -= movedist / 230;
			
			if (moveframe > 30) {
				move = false;
				drawBoard(gameBoard,winDecks,freeSpaces,undefined);
			}
			else
				moveframe++;
			
			//console.log("Animating move...");
			//console.log(movespeed);
			//console.log(movepos);
			requestAnimationFrame(animateMove);
		}
	}
	
	function winAnimation() {
		let fmat = new BoardDisp();
		let leftmost = fmat.findDrawX(gameBoard.length - 1) - (3 * (fmat.spacing2 + fmat.width));
		
		let drawcard = winDecks[wincard.index[0]];
		drawcard.face = 12 - wincard.index[1];
		drawCard(wincard.x,wincard.y, drawcard);
		
		wincard.x += wincard.dx;
		if (wincard.x < 0 - fmat.width - 30 || wincard.x > 830) {
			wincard.index[0]++;
			if (wincard.index[0] == 4) {
				wincard.index[0] = 0;
				wincard.index[1]++;
				//console.log(wincard.index);
			}
			let pos = Math.round(Math.random());
			if (pos)
				wincard.dx = Math.floor(Math.random() * 3) + 1;
			else
				wincard.dx = Math.floor(Math.random() * -1 * 4) - 3;
			wincard.dy = (Math.ceil(Math.random() * 4) - 1);
			
			wincard.x = leftmost + wincard.index[0] * (fmat.width+fmat.spacing2);
			wincard.y = fmat.vmargin;
			
			wincard.damping = 0.75 + ((Math.random() * 8) / 100)
		}
		
		wincard.y += wincard.dy;
		if (wincard.y > 500 - fmat.height) {
			wincard.dy *= (-1 * wincard.damping);
			wincard.y = 500 - fmat.height;
		}
		
		wincard.dy += wincard.grav;
		
		if (wincard.index[0] < 4 && wincard.index[1] < 13)
			requestAnimationFrame(winAnimation)
		else {
			let draw2d = document.getElementById("canvas").getContext("2d");
			draw2d.fillStyle = "black";
			draw2d.font = "20px sans-serif";
			draw2d.fillText("win", 350,230);
			return;
		}
	}
	
	function interpretInput(click) {
		
		// Input: ith free cell:
		//		[-1,i]
		// Input: ith win deck:
		//		[-2,i];
		// Input: jth member of ith row in main area
		//		[i,j]
		
		//console.log(click);
		
		let fmat = new BoardDisp();
		if (click[1] > fmat.vmargin && click[1] < fmat.vmargin + fmat.height) {
			//console.log("Clicked in upper area");
			
			if (click[0] < 375) { // not strictly necessary, but it saves a few computations
				
				// Clicked on free cell
				for (let i = 0; i < freeSpaces.length; i++) {
					//console.log("Checking free cell " + i);
					if (click[0] > fmat.lmargin + fmat.offset + (fmat.spacing2+fmat.width) * i &&
					click[0] < fmat.lmargin + fmat.offset + fmat.width + (fmat.spacing2+(fmat.width)) * i) {
						var draw2d = document.getElementById("canvas").getContext("2d");
						/*draw2d.fillStyle = "black";
						draw2d.beginPath();
						draw2d.moveTo(fmat.lmargin + fmat.offset + (fmat.spacing2+fmat.width) * i, fmat.vmargin);
						draw2d.lineTo(fmat.lmargin + fmat.offset + (fmat.spacing2+fmat.width) * i, fmat.vmargin+fmat.height);
						draw2d.stroke();
						draw2d.beginPath();
						draw2d.moveTo(fmat.lmargin + fmat.offset + fmat.width + (fmat.spacing2+(fmat.width)) * i, fmat.vmargin);
						draw2d.lineTo(fmat.lmargin + fmat.offset + fmat.width + (fmat.spacing2+(fmat.width)) * i, fmat.vmargin+fmat.height);
						draw2d.stroke();*/
						console.log("Clicked on free cell " + i);
						return [-1, i];
					}
				}
			}
			else if (click[0] >= 375 && click[0] <= 425) {
				let dist = Math.sqrt( (click[0] - 400) ** 2 + (click[1] - (fmat.vmargin + (fmat.height/2))) ** 2);
				if (dist < 20) {
					console.log("Clicked on undo button");
					return [-3,0];
				}
			}
			else {
				
				// Clicked on win deck
				//if (click[0] > 400) {
					let leftmost = fmat.findDrawX(gameBoard.length - 1) - (3 * (fmat.spacing2 + fmat.width));
					for (let i = 0; i < /*4*/winDecks.length; i++) {
						console.log("Checking win deck " + i);
						//var draw2d = document.getElementById("canvas").getContext("2d");
						//draw2d.fillStyle = "black";
						//draw2d.beginPath();
						//draw2d.moveTo(leftmost + /*fmat.offset*/ + (fmat.spacing2+fmat.width) * i, fmat.vmargin);
						//draw2d.lineTo(leftmost + /*fmat.offset*/ + (fmat.spacing2+fmat.width) * i, fmat.vmargin + fmat.height);
						//draw2d.stroke();
						//draw2d.beginPath();
						//draw2d.moveTo(leftmost + /*fmat.offset*/ + fmat.width + (fmat.spacing2+fmat.width) * i, fmat.vmargin);
						//draw2d.lineTo(leftmost + /*fmat.offset*/ + fmat.width + (fmat.spacing2+fmat.width) * i, fmat.vmargin + fmat.height);
						//draw2d.stroke();
						if (click[0] > leftmost + fmat.offset + (fmat.spacing2+fmat.width) * i &&
						click[0] < /*fmat.lmargin*/leftmost + /*fmat.offset + */fmat.width + (fmat.spacing2+(fmat.width)) * i) {
							console.log("Clicked on win deck " + i);
							return [-2, i];
						}
					}
					// With all the checks I do on the output, it makes me wonder
					// are the checks above really necessary?
					if (winDecks.length < 4) {
						return [-2, 3];
					}
					
				//}
			}
			console.log("Nothing clicked on");
			
		}
		else if (click[1] > fmat.areatop) {
			
			// Clicked in the main board area
			let rowclicked = fmat.findRow(click[0]);
			//console.log("Clicked on row " + rowclicked);
			if (rowclicked > -1 && rowclicked < gameBoard.length) {
				let colclicked = fmat.findCol(gameBoard[rowclicked].length, click[1]);
				console.log("Clicked on card " + rowclicked + ", " + colclicked);
				return [rowclicked, colclicked];
			}
			
		}
		else {
			console.log("Clicked on invalid space");
			return undefined;
		}
	}
	
	drawBoard(gameBoard, winDecks, freeSpaces, undefined);
	//document.getElementById("canvas").getContext("2d").fillRect(40,40, 100,100);
	
	
	
	
	onmousemove = (e) => {
		if (!win && animate) {
			animatepos[0] = e.offsetX - cardoffset[0];
			animatepos[1] = e.offsetY - cardoffset[1];
			
			travel[2] += Math.sqrt( (e.offsetX - travel[0]) ** 2 + (e.offsetY - travel[1]) ** 2 );
			travel[0] = e.offsetX;
			travel[1] = e.offsetY;
			//console.log(travel[2]);
		}
	};
	
	
	
	
	onmousedown = (e) => {
		
		if (!win) {
		
		console.log("-------");
		
		var input = [e.offsetX, e.offsetY];
		
		// Interpret input
		var cardclicked = interpretInput(input);
		
		if (cardclicked != undefined) { if (cardclicked[0] != undefined && cardclicked[1] != undefined) {
			move1 = [cardclicked[0], cardclicked[1]];
		}
		else {move1 = [];}} else {move1 = [];}
		//console.log(move1);
		
		if (move1[0] > -1) {
			//console.log("Checking run from " + move1[1] + " to " + (gameBoard[move1[0]].length-1));
			if (move1[1] < gameBoard[move1[0]].length - 1) {
				let i = move1[1];
				//console.log(i + " < " + (gameBoard[move1[0]].length-1));
				while (i < gameBoard[move1[0]].length - 1) {
					if (gameBoard[move1[0]][i].face == gameBoard[move1[0]][i+1].face + 1
					&& gameBoard[move1[0]][i].color() != gameBoard[move1[0]][i+1].color()) {
						i++;
					}
					else
						break;
				}
				console.log("Checked run of length " + (i - move1[1]));
				if (i < gameBoard[move1[0]].length - 1) {
					move1 = [];
					console.log("Clicked on card with non-consecutive run");
				}
			}
		}
		
		if (move1[0] == -2) {
			if (winDecks.length < move1[1]) {
				move1 = [];
				console.log("Can't move from empty win deck");
			}
		}
		if (move1[0] == -1) {
			//console.log("Checking if free cell " + move1[1] + " is empty");
			if (freeSpaces[move1[1]] == undefined) {
				move1 = [];
				console.log("Can't move from empty free cell");
			}
		}
		
		// Animation stuff
		if (move1.length > 0 && move1[0] != -3) {
			console.log(move1);
			animatedcard = cardclicked;
			animate = true;
			//animatepos[0] = input[0];
			//animatepos[1] = input[1];
			
			let fmat = new BoardDisp();
			let cardpos;
			if (cardclicked[0] > -1)
				cardpos = [fmat.findDrawX(move1[0]), fmat.findDrawY(gameBoard[move1[0]].length,move1[1])];
			else if (cardclicked[0] == -1) 
				cardpos = [fmat.lmargin + fmat.offset + cardclicked[1] * (fmat.width + fmat.spacing2), fmat.vmargin];
			else if (cardclicked[0] == -2) {
				let leftmost = fmat.findDrawX(gameBoard.length - 1) - (3 * (fmat.spacing2 + fmat.width));
				cardpos = [leftmost + fmat.cardclicked[1] * (fmat.width + fmat.spacing2), fmat.vmargin];
			}
			console.log("Animating " + animatedcard);
			cardoffset[0] = input[0] - cardpos[0];
			cardoffset[1] = input[1] - cardpos[1];
			
			animatepos[0] = input[0] - cardoffset[0];
			animatepos[1] = input[1] - cardoffset[1];
			
			travel[0] = input[0];
			travel[1] = input[1];
			
			requestAnimationFrame(animateDrag);
		}
		
		//console.log(animate);
		//console.log(animatedcard);
		//console.log(animatepos);
		//console.log(cardoffset);
		
		}
	};
	
	onmouseup = (e) => {
		
		if (!win) {
		
		animate = false;
		//drawBoard(gameBoard, winDecks, freeSpaces, undefined);
		
		var input = [e.offsetX,e.offsetY];
		
		var cardclicked = interpretInput(input);
		
		if (cardclicked != undefined) { if (cardclicked[0] != undefined && cardclicked[1] != undefined) {
			move2 = [cardclicked[0], cardclicked[1]];
		}
		else {move2 = [];}} else {move2 = [];}
		
		if (move1.length > 0 && move2.length > 0) {
			//console.log("Checking move");
			
			if ((move1[0] == move2[0] && move1[1] == move2[1]) && travel[2] < 120) {
				// automatically find move
				
				// Undo
				if (move1[0] == -3 && moves.length > 0) {
					undo = true;
					
					// I tried using the move1/move2 system I set up, but it wasn't
					//deterministic enough. :/ So now I get to implement this code for
					//the third time.  yay
					//let undomove = moves[moves.length-1];
					let undo1 = moves[moves.length-1].to;
					let undo2 = moves[moves.length-1].from;
					if (undo1[0] == -2) { // Take off the winDecks...
						if (undo2[0] == -1) // ...and put it on a free cell
							freeSpaces[undo2[1]] = winDecks[undo1[1]];
						else if (undo2[0] > -1) // ...and put it on the main area
							gameBoard[undo2[0]].push(winDecks[undo1[1]]);
						
						// Delete from winDeck
						if (winDecks[undo1[1]].face == 0)
							winDecks.pop();
						else
							winDecks[undo1[1]].face--;
					}
					else if (undo1[0] == -1) { // Take off a free cell...
						if (undo2[0] == -2) { // ...and put it on the winDecks
							if (undo2[1] >= winDecks.length) {
								let newcard = freeSpaces[undo1[1]];
								winDecks.push(newcard);
							}
							else
								winDecks[undo2[1]].face++
							freeSpaces[undo1[1]] = undefined;
						}
						else if (undo2[0] == -1) { // ...and put it on a free cell
							if (freeSpaces[undo2[1]] == undefined) {
								freeSpaces[undo2[1]] = freeSpaces[undo1[1]];
								freeSpaces[undo1[1]] = undefined;
							}
							else {
								let tempundo = freeSpaces[undo1[1]];
								freeSpaces[undo1[1]] = freeSpaces[undo2[1]];
								freeSpaces[undo2[1]] = tempundo;
							}	
						}
						else if (undo2[0] > -1) { // ...and put it on the main area
							gameBoard[undo2[0]].push(freeSpaces[undo1[1]]);
							freeSpaces[undo1[1]] = undefined;
						}
					}
					else if (undo1[0] > -1) { // Take off the main area...
						if (undo2[0] == -2) { // ...and put it on the winDecks
							if (undo2[1] >= winDecks.length) {
								let newcard = gameBoard[undo1[0]][undo2[0]];
								winDecks.push(newcard);
							}
							else {
								winDecks[undo2[1]].face++;
							}
							gameBoard[undo1[0]].pop();
						}
						else if (undo2[0] == -1) { // ...and put it on a free cell
							freeSpaces[undo2[1]] = gameBoard[undo1[0]][undo1[1]];
							gameBoard[undo1[0]].pop();
						}
						else if (undo2[0] > -1) { // ...and put it on the main area
							if (undo1[1] < gameBoard[undo1[0]].length-2) {
								let stackdiff = gameBoard[undo1[0]].length - undo1[1] - 1;
								console.log(stackdiff);
								for (let i = undo1[1] + 1; i < gameBoard[undo1[0]].length; i++) {
									gameBoard[undo2[0]].push(gameBoard[undo1[0]][i]);
									console.log("Putting " + gameBoard[undo1[0]][i].print() + " back on row " + undo2[0]);
								}
								for (let i = 0; i < stackdiff; i++)
									gameBoard[undo1[0]].pop();
							}
							else {
								gameBoard[undo2[0]].push(gameBoard[undo1[0]][gameBoard[undo1[0]].length-1]);
								gameBoard[undo1[0]].pop();
							}
						}
					}
					
					moves.pop();
					console.log("Popping moves");
				}
				
				else {
					console.log("Looking for auto move from " + move1[0] + "," + move1[1]);
					
					// Find automatic move
					if (move1[0] == -2) {
						for (let i = 0; i < freeSpaces.length; i++) {
							if (freeSpaces[i] != undefined) {
								move2[0] = -1;
								move2[1] = i;
								break;
							}
						}/*
						for (let i = 0; i < freeSpaces.length; i++) {
							if (freeSpaces[i].suit == gameBoard[move1[0]][move1[1]].suit
							&& freeSpaces[i].face + 1 == gameBoard[move1[0]][move1[1]].face) {
								move2[0] = -2;
								move2[1] = i;
							}
						}*//*
						if (freeSpaces.length < 4) {
							move2[0] = -1;
							move2[1] = freeSpaces.length - 1;
						}*/
						for (let i = 0; i < gameBoard.length; i++) {
							if (gameBoard[i][gameBoard[i].length-1].color() != winDecks[move1[1]].color()
							&& gameBoard[i][gameBoard[i].length-1].face == winDecks[move1[1]].face + 1) {
								move2[0] = i;
								move2[1] = gameBoard[i].length - 1;
							}
						}
					}
					
					if (move1[0] == -1) {
						for (let i = 0; i < gameBoard.length; i++) {
							if (gameBoard[i].length == 0) {
								move2[0] = i;
								move2[1] = 0;
							}
							else {
								if (gameBoard[i][gameBoard[i].length-1].color() != freeSpaces[move1[1]].color()
								&& gameBoard[i][gameBoard[i].length-1].face == freeSpaces[move1[1]].face + 1) {
									move2[0] = i;
									move2[1] = gameBoard[i].length - 1;
								}
							}
						}
						for (let i = 0; i < winDecks.length; i++) {
							if (freeSpaces[move1[1]].suit == winDecks[i].suit
							&& freeSpaces[move1[1]].face == winDecks[i].face + 1) {
								move2[0] = -2;
								move2[1] = i;
								//move2[1] = 3;
							}
						}
					}
					
					if (move1[0] > -1) {
						if (move1[1] == gameBoard[move1[0]].length - 1) {
							let i = 0;
							while (i < freeSpaces.length && freeSpaces[i] != undefined) { i++; }
							if (i < freeSpaces.length) {
								move2[0] = -1;
								move2[1] = i;
							}
						}/*
						for (let i = 0; i < freeSpaces.length; i++) {
							if (freeSpaces[i] == undefined) {
								move2[0] = -1;
								move2[1] = i;
								break;
							}
						}*//*
						for (let i = 0; i < freeSpaces.length; i++) {
							if (freeSpaces[i].suit == gameBoard[move1[0]][move1[1]].suit
							&& freeSpaces[i].face + 1 == gameBoard[move1[0]][move1[1]].face) {
								move2[0] = -2;
								move2[1] = i;
							}
						}*//*
						if (freeSpaces.length < 4) {
							move2[0] = -2;
							move2[1] = freeSpaces.length - 1;
						}*/
						for (let i = 0; i < gameBoard.length; i++) {
							if (i != move1[0]) {
								if (gameBoard[i].length == 0) {
									move2[0] = i;
									move2[1] = 0;
								}
								else {
									//for (let i = 0; i < gameBoard.length; i++) {
										if (gameBoard[i][gameBoard[i].length-1].color() != gameBoard[move1[0]][move1[1]].color()
										&& gameBoard[i][gameBoard[i].length-1].face == gameBoard[move1[0]][move1[1]].face + 1) {
											move2[0] = i;
											move2[1] = gameBoard[i].length - 1;
										}
									//}
								}
							}
							//else {console.log("Got to i = " + move1[0]);}
						}
						if (gameBoard[move1[0]][move1[1]].face == 0) {
							move2[0] = -2;
							move2[1] = winDecks.length;
						}
						for (let i = 0; i < winDecks.length; i++) {
							if (gameBoard[move1[0]][move1[1]].suit == winDecks[i].suit
							&& gameBoard[move1[0]][move1[1]].face == winDecks[i].face + 1) {
								move2[0] = -2;
								move2[1] = i;
								//move2[1] = 3;
							}
						}
					}
					
					console.log("Found move: " + move2[0] + "," + move2[1]);
					move = true;
				}
			}
			
			// Action based on detected move
			
			if (move1[0] == -2) {
				// move from win deck...
				
				if (move2[0] == -1) {
					// ...onto free cell
					
					if (freeSpaces.length < 4 && winDecks[move1[1]].face > 0) {
						freeSpaces.push(winDecks[move1[1]]);
						winDecks[move1[1]].face--;
						console.log("Moved " + freeSpaces[freeSpaces.length-1].print() + " onto a free cell");
					}
					
				}
				else if (move2[0] > -1) {
					// ... onto main area
					
					let row = move2[0];
					if (gameBoard[row].length == 0) {
						gameBoard[row].push(winDecks[move1[1]]);
						winDecks[move1[1]].face--;
						console.log("Moved " + gameBoard[row][gameBoard[row].length-1].print() + " onto row " + row);
					}
					if (gameBoard[row][gameBoard[row].length-1].color() != winDecks[move1[1]].color()
					&& gameBoard[row][gameBoard[row].length-1].face == winDecks[move1[1]].face + 1) {
						gameBoard[row].push(winDecks[move1[1]]);
						winDecks[move1[1]].face--;
						console.log("Moved " + gameBoard[row][gameBoard[row].length-1].print() + " onto row " + row);
					}
				}
			}
			// The way the free cells are set up don't make them very dynamic
			// Currently, they work almost identically to the win decks
			// You need to put some thought into how you want the free cells to work
			//
			// Solved...? :)
			else if (move1[0] == -1) {
				// move from free cell...
				
				if (move2[0] == -2) {
					// ...onto win deck
					
					if (freeSpaces[move1[1]].face == 0) {
						console.log("Adding " + freeSpaces[move1[1]].print() + " to win decks");
						winDecks.push(freeSpaces[move1[1]]);
						freeSpaces[move1[1]] = undefined;
					}
					if (winDecks.length > move2[1]) {
						if (freeSpaces[move1[1]].suit == winDecks[move2[1]].suit
						&& freeSpaces[move1[1]].face == winDecks[move2[1]].face + 1) {
							winDecks[move2[1]].face++;
							freeSpaces[move1[1]] = undefined;
							console.log("Moved " + winDecks[move2[1]].print() + " onto the win deck");
						}
					}
					
				}
				else if (move2[0] == -1) {
					// ...onto free cell?
					
					if (freeSpaces[move2[1]] == undefined) {
						freeSpaces[move2[1]] = freeSpaces[move1[1]];
						freeSpaces[move1[1]] = undefined;
					}
					else {
						let temp = freeSpaces[move1[1]];
						freeSpaces[move1[1]] = freeSpaces[move2[1]];
						freeSpaces[move2[1]] = temp;
					}
				}
				else if (move2[0] > -1) {
					// ...onto main area
					
					for (let i = 0; i < gameBoard.length; i++) {
						if (gameBoard[i].length == 0) {
							gameBoard[i].push(freeSpaces[move1[1]]);
							freeSpaces[move1[1]] = undefined;
							console.log("Moved " + gameBoard[i][0].print() + " onto row " + i);
							break;
						}
						else if (freeSpaces[move1[1]].color() != gameBoard[i][gameBoard[i].length-1].color()
						&& freeSpaces[move1[1]].face + 1 == gameBoard[i][gameBoard[i].length-1].face) {
							gameBoard[i].push(freeSpaces[move1[1]]);
							freeSpaces[move1[1]] = undefined;
							console.log("Moved " + gameBoard[i][gameBoard[i].length-1].print() + " onto row " + i);
							break;
						}
					}
				}
			}
			else {
				// move from main area...
				
				if (move2[0] == -2) {
					// ...onto win deck
					console.log("move1: " + move1);
					console.log("move2: " + move2);
					
					let row = move1[0];
					let col = move1[1];
					if (gameBoard[row][col].face == 0) {
						console.log("Adding " + gameBoard[row][col].print() + " to win decks");
						let newcard = new Card(0, gameBoard[row][col].suit);
						winDecks.push(newcard);
						gameBoard[row].pop();
					}
					else if (winDecks.length > move2[1]) {
						console.log("Adding " + gameBoard[row][col].print() + " to win decks");
						if (gameBoard[row][col].suit == winDecks[move2[1]].suit
						&& gameBoard[row][col].face == winDecks[move2[1]].face + 1) {
							//let currentface = winDecks[move2[1]].face;
							//winDecks[move2[1]].face = currentface + 1;
							winDecks[move2[1]].face++;
							gameBoard[row].pop();
							console.log("Moved " + winDecks[move2[1]].print() + " onto the win deck");
							console.log(winDecks);
						}
					}
				}
				else if (move2[0] == -1) {
					// ...onto free cell
					
					let row = move1[0];
					let col = move1[1];
					if (col == gameBoard[row].length-1) {
						/*if (freeSpaces.length < 4) {
							freeSpaces.push(gameBoard[row][col]);
							gameBoard[row].pop();
							console.log("Moved " + freeSpaces[freeSpaces.length-1].print() + " onto a free cell");
						}*/
						for (let i = 0; i < freeSpaces.length; i++) {
							if (freeSpaces[i] == undefined) {
								freeSpaces[i] = gameBoard[row][col];
								gameBoard[row].pop();
								console.log("Moved " + freeSpaces[i].print() + " onto a free cell");
								break;
							}
						}
					}
					/*else
						console.log(col + " < " + (gameBoard[row].length-1));*/
				}
				else if (move2[0] > -1) {
					// ...onto main area
					console.log("Moving from row " + move1[0] + " to row " + move2[0]);
					
					if (gameBoard[move2[0]].length == 0) {
						let numcards2move = gameBoard[move1[0]].length - move1[1];
						for (let i = move1[1]; i < gameBoard[move1[0]].length; i++) {
							console.log("Moved " + gameBoard[move1[0]][i].print() + " onto row " + move2[1]);
							gameBoard[move2[0]].push(gameBoard[move1[0]][i]);
						}
						for (let i = 0; i < numcards2move; i++) {
							gameBoard[move1[0]].pop();
						}
					}
					else {
						if (gameBoard[move1[0]][move1[1]].color() != gameBoard[move2[0]][move2[1]].color()
						&& gameBoard[move1[0]][move1[1]].face + 1 == gameBoard[move2[0]][move2[1]].face) {
							let numcards2move = gameBoard[move1[0]].length - move1[1];
							for (let i = move1[1]; i < gameBoard[move1[0]].length; i++) {
								
								//gameBoard[move2[0]].push(gameBoard[move1[0]].pop());
								console.log("Moved " + gameBoard[move1[0]][i].print() + " onto row " + move2[1]);
								
								// Code is incomplete
								// Not anymore
								
								gameBoard[move2[0]].push(gameBoard[move1[0]][i]);
							}
							for (let i = 0; i < numcards2move; i++) {
								gameBoard[move1[0]].pop();
							}
						}
					}
				}
			}
			
			
			if (move1[0] == move2[0] && move1[1] == move2[1])
				move = false;
			
			if (move) {
				
				
				
				//console.log(move1 + "," + move2)
				console.log("Animating move...");
				// Finish this code
				// initialize movepos
				// initialize movedir
				// initialize movespeed
				// call animateMove() animationframe
				
				animatedcard = move2;
				
				let leftmost = fmat.findDrawX(gameBoard.length - 1) - (3 * (fmat.spacing2 + fmat.width));
				if (move1[0] > -1) {
					movepos[0] = fmat.findDrawX(move1[0]);
					movepos[1] = fmat.findDrawY(gameBoard[move1[0]].length,move1[1]+1);
				}
				else if (move1[0] == -1) {
					movepos[0] = fmat.lmargin + move1[1] * (fmat.width+fmat.spacing2);
					movepos[1] = fmat.vmargin;
				}
				else if (move1[0] == -2) {
					movepos[0] = leftmost + move1[1] * (fmat.width+fmat.spacing2);
					movepos[1] = fmat.vmargin;
				}
				
				if (move2[0] > -1) {
					let move2pos = [fmat.findDrawX(move2[0]),fmat.findDrawY(gameBoard[move2[0]].length,move2[1]+1)];
					movedist = distance(movepos[0],movepos[1],movepos[0],move2pos[0],move2pos[1]);
					movedir[0] = (move2pos[0] - movepos[0]) / movedist;
					movedir[1] = (move2pos[1] - movepos[1]) / movedist;
				}
				else if (move2[0] == -1) {
					let move2pos = fmat.lmargin + move2[1] * (fmat.width+fmat.spacing2);
					movedist = distance(movepos[0],movepos[1],move2pos,fmat.vmargin);
					movedir[0] = (move2pos - movepos[0]) / movedist;
					movedir[1] = (fmat.vmargin - movepos[1]) / movedist;
				}
				else if (move2[0] == -2) {
					let move2pos = leftmost + move2[1] * (fmat.width+fmat.spacing2);
					movedist = distance(movepos[0],movepos[1],move2pos,fmat.vmargin);
					movedir[0] = (move2pos - movepos[0]) / movedist;
					movedir[1] = (fmat.vmargin - movepos[1]) / movedist;
				}
				
				movespeed = 0;
				moveframe = 0;
				//console.log(movepos);
				//console.log(movedir);
				//console.log(animatedcard);
				
				animateMove();
				
			}
			
			
			let checkwin = 0;
			for (let i = 0; i < winDecks.length; i++) {
				if (winDecks[i].face == 12)
					checkwin++;
			}
			if (checkwin == 4) {
				win = true;
				document.getElementById("alert").style.color = "green";
				document.getElementById("alert").innerHTML = "You win!";
				
				wincard.dx = -3;
				wincard.dy = 0;
				requestAnimationFrame(winAnimation);
			}
			
			
		}
		else {
			console.log("Move involving invalid space - no action");
		}
		
		console.log("Drawing board");
		drawBoard(gameBoard, winDecks, freeSpaces, undefined);
		travel[2] = 0;
		
		}
		
		if (move1[0] != -3)
			moves.push({from: move1, to: move2});
		undo = false;
		//console.log(moves);
		
	};
}

function freecell() {
	
	const debugDeck = false;
	
	document.getElementById("alert").innerHTML = "";
	
	var deckunshuffled = [];
	
	for (let i = 0; i < 52; i++) {
		let faceval = i % 13;
		let suit;
		if (Math.floor(i / 13) == 0)
			suit = "s";
		else if (Math.floor(i / 13) == 1)
			suit = "c";
		else if (Math.floor(i / 13) == 2)
			suit = "d";
		else if (Math.floor(i / 13) == 3)
			suit = "h";
		let newCard = new Card(faceval, suit);
		deckunshuffled.push(newCard);
	}
	
	var deck = [];
	
	if (!debugDeck) {
		for (let i = 0; i < 52; i++) {
			let randcard = Math.floor(Math.random() * deckunshuffled.length);
			
			deck.push(deckunshuffled[randcard]);
			
			for (let j = randcard; j < deckunshuffled.length - 1; j++)
				deckunshuffled[j] = deckunshuffled[j+1];
			
			deckunshuffled.pop();
		}
	
	delete(deckunshuffled);
	}
	
	var table = [[], [], [], [], [], [], [], []];
	
	if (debugDeck) {
		for (let i = 0; i < 4; i++) {
			for (let j = 12; j > -1; j--)
				table[i].push(deckunshuffled[i * 13 + j]);
		}
	}
	else {
		for (let i = 0; i < 52; i++)
			table[i%8].push(deck[i]);
	}
	
	delete(deck);
		
	gameLoop(table);
}
</script>

</head>

<body>

	<nav>
		<ul>
			<!--li><a href="../index.html">Back</a></li-->
			<li><a href="Main_Page/projects_page.html">Back to Project List</a></li>
			<li><a href="canvasthing2.html">Spider</a></li>
			<li><a href="canvasthing3.html">Klondike</a></li>
			<li>FreeCell</li>
		</ul>
	</nav>

<div>
<button onclick="freecell()">New Game</button>
<p id="alert"></p>
</div>

<canvas id="canvas" width="800" height="500">Freecell</canvas>

<div>
<h3>Warning: auto-moving a 2 onto the win deck will make it impossible to win!</h3>
<p>Use drag-and-drop instead. You may need to do it twice. My best guess is that it's related to the undo button, because this wasn't a problem before I added it.</p>
<p>If you want to see the win animation without playing an entire game, go into the code and set debugDeck = true in the function freecell().</p>
</div>

<div>
<h3>To-do</h3>
<ul>
<li>Face value doesn't increase on winDeck on auto-move</li>
<li>Aces don't like moving off the winDeck</li>
<li>Fix graphical issues</li>
	<ul>
	<li>target card disappears on auto-move</li>
	<li>blank space disappears on auto-move</li>
	<li>aces don't animate on auto-move</li>
	</ul>
<li>Fix undo issues</li>
	<ul>
	<li>Very inconsistent = difficult to debug</li>
	</ul>
<li>Clean up code</li>
	<ul>
	<li>See comments in script</li>
	</ul>
<li>Make canvas variable size for accessibility</li>
</ul>
</div>

</body>
</html>
